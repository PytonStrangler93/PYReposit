from itertools import accumulate


class multifilter:

    def judge_half(pos, neg):
        # допускает элемент, если его допускает хотя бы половина фукнций (pos
        # >= neg)
        return pos >= neg

    def judge_any(pos, neg):
        # допускает элемент, если его допускает хотя бы одна функция (pos >= 1)
        return pos >= 1

    def judge_all(pos, neg):
        # допускает элемент, если его допускают все функции (neg == 0)
        return neg == 0

    def __init__(self, iterable, *funcs, judge=judge_any):
        self.iterable = iterable
        self.funcs = funcs
        self.judge = judge

    def __iter__(self):
        # возвращает итератор по результирующей последовательности.
        for i in self.iterable:
            pos, neg = 0, 0
            for x in self.funcs:
                if x(i) == True:
                    pos += 1
                else:
                    neg += 1
            if self.judge(pos, neg) == True:
                yield i


# def mul2(x):
#     return x % 2 == 0

# def mul3(x):
#     return x % 3 == 0

# def mul5(x):
#     return x % 5 == 0


# a = [i for i in range(31)] # [0, 1, 2, ... , 30]

# print(list(multifilter(a, mul2, mul3, mul5)))
# # [0, 2, 3, 4, 5, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30]

# print(list(multifilter(a, mul2, mul3, mul5, judge=multifilter.judge_half)))
# # [0, 6, 10, 12, 15, 18, 20, 24, 30]

# print(list(multifilter(a, mul2, mul3, mul5, judge=multifilter.judge_all)))
# # [0, 30]


# GOOOOOOOOOD!!!!
class multifilter:

    def judge_half(fx): return sum(fx) >= len(fx) / 2
    def judge_any(fx): return any(fx)
    def judge_all(fx): return all(fx)

    def __init__(self, iterable, *funcs, judge=judge_any):
        self.iterable = iterable
        self.funcs = funcs
        self.judge = judge

    def __iter__(self):
        return (x for x in self.iterable if self.judge(
            [f(x) for f in self.funcs]))


class multifilter(list):
    def judge_half(pos, neg):
        return pos >= neg

    def judge_any(pos, neg):
        return pos >= 1

    def judge_all(pos, neg):
        return neg == 0

    def __init__(self, iterable, *funcs, judge=judge_any):
        for i in iterable:
            pos, neg = 0, 0
            for f in funcs:
                if f(i):
                    pos += 1
                else:
                    neg += 1
            if judge(pos, neg):
                self += [i]


# Это попытка написать эффективное решение и при этом сохранить функциональный стиль программирования.
# В качестве отправной точки был взят код от Ayvar Straut набравший максимальное количество баллов.
# Среди прочих преобразований пришлось изменить сингатуру функции judge, плюс воспользоваться генераторами в виде лист компрехеншион
# (о которых будет рассказано в следующем видео лектора) и функцией accumulate из пакета itertools.
# Чтобы стало понятно зачем понадобилось изменять сингатуру функции judge:  обратите внимание на тот факт,
# что во многих случаях результат любой из функций judge становится известен за долго до того как были запущены все тестирующие функции.
# Для any достаточно одного удачного теста, для all - одного неудачного теста, а для half - половины удачных тестов. Чтобы этим воспользоваться,
# мы должны прогонять список тестирующие функции внутри самих функций judge и в нужный момент останавливать цикл.
# Но можно поступить по другому и передовать в функцию judge генератор прогона тестирующих функций.
# Если в лист компрехеншион для тестирующих функций поменять квадратные скобки на круглые -  получится нужный нам генератор:
# (f(x) for f in self.funcs)
# Для "прокрутки" генератора внутри функции judge, в случае с any и all, как по заказу, есть одноимённые функции в языке Питон:
# def judge_any(self, gen): return any(gen)
# def judge_all(self, gen): return all(gen)
# В случае с half дела обстоят несколько сложнее. Можно было воспользоватся функцией sum, но это, очевидо,
# неэффективное решение, так как оно потребывало бы обхода всех тестирующих функций независимо от результатов тестирования.
# Можно было конечно написать явный цикл for внутри функции judge_half и в нём подсчитывать количество успешных тестов,
# чтобы остановится как только наберётся половина таковых. Но мне захотелось сахранить стиль функционального программирования.
# Функция accumulate в своём самом простом виде работает как функция sum, но выдаёт не конечную сумму,
# а генератор списка всех промежуточных результатов суммирования! Легко заметить что суммирование булевских значений
# равносильно подсчету элементов значение которых True, вед значения False преобразуются в числа ноль и не увеличивают сумму!
# Поверх этого герератора мы накладываем другой генератор с помощью всё того же лист компрехеншион:
# (cnt >= self.half_funcs for cnt in accumulate(gen))
# т.е. как только промежуточная сумма удачных тестов станет больше или равна половине всех тестов, новый генератор начнёт выдавать значения True.
# Теперь всё что нам осталось, это скормить полученный генератор функции any:
# def judge_half(self, gen): return any( cnt >= self.half_funcs for cnt in accumulate(gen) )
# Обратите внимание что генератор на основе лист компрехеншн внутри вызова функции any записывается без своих дополнительных круглых скобок!
# Такое возможно внутри вызова функции, если генератор является единственным аргументом! Важно понять почему мы отдаём предпочтение генераторам а не простым спискам.
# Дело в том что в нашем случае мы имеем дело с каскадом преобразований производимых над списком тестирующих функций. В случае с обычными списками,
# каждое такое преобразование будет запускаться по всем элементам списка и каждый раз будет формироваться новый список. Мы же хотим остановится как
# только отпадёт необходимость продолжать тестирование! Генераторы дают нам такую возможность! И не важно что у нас целый каскад генераторов,
# этот каскад будет запускаться отдельно и последовательно для каждой тестирующей функции из картежа тестирующих функций! Ещё один момент, число
# равное половине количества тестирующих функции считается и сохроняется ещё в конструкторе (ведь кортеж тестирующих функций передаётся
# в самом конструкторе и в дальнейшем не изменяется), чтобы  потом его каждый раз не перещитывать в функции judge_half. Вы спросите зачем нам
# так сильно заботится об эффективности прогона тестирующих функий, ведь их у нас всего три? Представьте что тестирующих функций в кортеже будет
# сотни или тысячи. Вы не хотите обходить весь кортеж, когда , скажем,  уже на 3-ем тесте можно вернуть результат!
# P.S. Функция accumulate и пакет itertools в целом стали для меня настоящим открытием.
# Функия accumulate сделала то что не смогли ни sum ни reduce, а itertools в купе с генераторами позволяет в
# определённой степени приблизить возможности итерации в стиле функционального программирования к тем, что  доступны в явном цикле for.
# Два вопрос остался для меня открытым: почему вызывая метод judge я вынужден был явно указывать self в качестве первого параметра?
# Почему сам  Константин_Зайцев в своём варианте решения вообще не указал self в качестве параметра в объявлении методов judge?
# Надеюсь уважаемые знатоки языка Питон подскажут ответы на эти вопросы.


class multifilter:

    def judge_half(
        self, gen): return any(
        cnt >= self.half_funcs for cnt in accumulate(gen))

    def judge_any(self, gen): return any(gen)
    def judge_all(self, gen): return all(gen)

    def __init__(self, iterable, *funcs, judge=judge_any):
        self.iterable = iterable
        self.funcs = funcs
        self.judge = judge
        self.half_funcs = sum(divmod(len(funcs), 2))

    def __iter__(self):
        return (x for x in self.iterable if self.judge(
            self, (f(x) for f in self.funcs)))
